console.log(`Function "ai_kochey_bot" up and running!`);

import {
  Bot,
  Context,
  GrammyError,
  HttpError,
  webhookCallback,
} from "https://deno.land/x/grammy@v1.8.3/mod.ts";

import {
  checkUsernameCodes,
  getRooms,
  getSupabaseUser,
  setMyWorkspace,
  setSelectedIzbushka,
  supabase,
} from "../_shared/utils/supabase/index.ts";
import { transliterate } from "../_shared/utils/openai/transliterate.ts";
import { create100MsRoom } from "../_shared/utils/100ms/create-room.ts";
import { getAiFeedback } from "../get-ai-feedback.ts";
import { DEV } from "../_shared/utils/constants.ts";

if (!Deno.env.get("TELEGRAM_BOT_TOKEN_AI_KOSHEY")) {
  throw new Error("TELEGRAM_BOT_TOKEN_AI_KOSHEY is not set");
}

if (!Deno.env.get("TELEGRAM_BOT_TOKEN_AI_KOSHEY_TEST")) {
  throw new Error("TELEGRAM_BOT_TOKEN_AI_KOSHEY_TEST is not set");
}

if (!Deno.env.get("AI_KOSHEY_URL")) {
  throw new Error("AI_KOSHEY_URL is not set");
}

if (!Deno.env.get("AI_KOSHEY_FLOWISE_TOKEN")) {
  throw new Error("AI_KOSHEY_FLOWISE_TOKEN is not set");
}

const aiKosheyUrl = Deno.env.get("AI_KOSHEY_URL");
const aiKosheyFlowiseToken = Deno.env.get("AI_KOSHEY_FLOWISE_TOKEN");

const tokenProd = Deno.env.get("TELEGRAM_BOT_TOKEN_AI_KOSHEY");
const tokenTest = Deno.env.get("TELEGRAM_BOT_TOKEN_AI_KOSHEY_TEST");

const token = DEV ? tokenTest : tokenProd;

const botAiKoshey = new Bot(token || "");

botAiKoshey.catch((err) => {
  const ctx = err.ctx;
  console.error(`Error while handling update ${ctx.update.update_id}:`);
  const e = err.error;
  if (e instanceof GrammyError) {
    console.error("Error in request:", e.description);
  } else if (e instanceof HttpError) {
    console.error("Could not contact Telegram:", e);
  } else {
    console.error("Unknown error:", e);
  }
});

botAiKoshey.command("start", async (ctx: Context) => {
  console.log("start");
  await ctx.replyWithChatAction("typing");
  const select_izbushka = ctx?.message?.text && ctx.message.text.split(" ")[1];

  if (select_izbushka) {
    const username = ctx?.update?.message?.from?.username;

    username && await setSelectedIzbushka(username, select_izbushka);

    ctx.reply(
      `üì∫ –ß—Ç–æ –∂, –ø—É—Ç–Ω–∏–∫ –¥–æ—Ä–æ–≥–æ–π, –¥–∞–±—ã —Ç—Ä–∞–Ω—Å–ª—è—Ü–∏—é –Ω–∞—á–∞—Ç—å, –Ω–∞–∂–º–∏ –∫–Ω–æ–ø–∫—É "–ò–∑–±—É—à–∫–∞" —Å–º–µ–ª–µ–µ –∏ –≤–µ—Å–µ–ª–∏—Å—å, –∏–±–æ –≤—Å–µ –ø—Ä–∏–≥–æ—Ç–æ–≤–ª–µ–Ω–æ –∫ –Ω–∞—á–∞–ª—É —Ç–≤–æ–µ–≥–æ –ø—É—Ç–µ—à–µ—Å—Ç–≤–∏—è –ø–æ —Ü–∏—Ñ—Ä–æ–≤—ã–º –ø—Ä–æ—Å—Ç–æ—Ä–∞–º!`,
    );
    return;
  } else {
    ctx.reply(
      `üè∞ –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –¢—Ä–∏–¥–µ–≤—è—Ç–æ–µ –¶–∞—Ä—Å—Ç–≤–æ, ${ctx?.update?.message?.from?.first_name}! \n–í—Å–µ–º–æ–≥—É—â–∞—è –ë–∞–±–∞ –Ø–≥–∞, –≤–ª–∞–¥—ã—á–∏—Ü–∞ —Ç–∞–π–Ω –∏ —á–∞—Ä–æ–¥–µ–π–Ω–∏—Ü–∞, –ø—Ä–µ–¥ –≤—Ä–∞—Ç–∞ –Ω–µ–≤–µ–¥–æ–º–æ–≥–æ –º–∏—Ä–∞ —Ç–µ–±—è –ø—Ä–∏–≤–µ—á–∞–µ—Ç.\n–ß—Ç–æ–± –∏–∑–±–∞ –∫ —Ç–µ–±–µ –ø–µ—Ä–µ–¥–∫–æ–º –æ–±–µ—Ä–Ω—É–ª–∞—Å—å, –∞ –Ω–µ –∑–∞–¥–æ–º —Å—Ç–æ—è–ª–∞, –Ω–µ –∑–∞–±—É–¥—å –ø—Ä–æ—à–µ–ø—Ç–∞—Ç—å –∫–∞–±—ã —Å–ª–æ–≤–µ—á–∫–æ-–ø—Ä–æ—Ö–æ–¥–Ω–æ–µ.`,
      {
        reply_markup: {
          force_reply: true,
        },
      },
    );

    return;
  }
});

botAiKoshey.on("message:text", async (ctx) => {
  console.log(ctx.message, "message");
  await ctx.replyWithChatAction("typing");
  const username = ctx.message.from.username;
  const inviter = ctx.message.text;
  // console.log(replyText, "replyText");

  const { data, error } = await supabase
    .from("users")
    .select("*")
    .eq("username", username);
  if (error) {
    console.error(error, "message:text -> users");
  }
  // console.log(data, "data");
  // console.log(error, "error");
  const user_id = data && data[0]?.user_id;
  // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç–≤–µ—Ç–æ–º (–µ—Å—Ç—å –ª–∏ reply_to_message)
  if (ctx.message.reply_to_message) {
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å–æ–¥–µ—Ä–∂–∏—Ç –ª–∏ —Ç–µ–∫—Å—Ç –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç
    const originalMessageText = ctx.message.reply_to_message.text;
    console.log(originalMessageText, "originalMessageText");
    if (
      originalMessageText &&
      (originalMessageText.includes("üè∞ –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å") ||
        originalMessageText.includes("üîí –û—Ö, —É–≤—ã –∏ –∞—Ö!"))
    ) {
      // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –æ—Ç–≤–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è

      // –î–µ–π—Å—Ç–≤–∏—è —Å –æ—Ç–≤–µ—Ç–æ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –Ω–∞–ø—Ä–∏–º–µ—Ä, —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Ç–æ–∫–µ–Ω–∞

      const { isInviterExist, invitation_codes, inviter_user_id } =
        await checkUsernameCodes(inviter as string);
      console.log(isInviterExist, "isInviterExist");
      try {
        if (isInviterExist) {
          const newUser = {
            first_name: ctx.message.from.first_name,
            last_name: ctx.message.from.last_name,
            username: ctx.message.from.username,
            language_code: ctx.message.from.language_code,
            telegram_id: ctx.message.from.id,
            inviter: inviter_user_id,
            invitation_codes,
          };
          console.log(newUser, "newUser");

          const { error: userDataError } = await supabase
            .from("users").insert([{ ...newUser }]);

          if (userDataError) {
            console.error(userDataError, "message:text -> users");
          }
          // const isPayment = true;

          const user_id = ctx.message.from.username;

          const userData = user_id && await getSupabaseUser(user_id);

          await setMyWorkspace(userData.user_id);

          ctx.reply(
            `üè∞ –ë–ª–∞–≥–æ–≤–æ–ª–∏ –≤–æ–π—Ç–∏ –≤ –≤–æ–ª—à–µ–±–Ω—ã–µ –ø—Ä–µ–¥–µ–ª—ã –¢—Ä–∏–¥–µ–≤—è—Ç–æ–≥–æ –¶–∞—Ä—Å—Ç–≤–∞, –≥–¥–µ —Å–∫–∞–∑–∞–Ω–∏–µ –æ–∂–∏–≤–∞–µ—Ç, –∞ —á—É–¥–µ—Å–∞ —Å–∞–º–æ —Å–æ–±–æ–π —Ä—è–¥–æ–º —Å—Ç—É–ø–∞—é—Ç. ${ctx.update.message?.from.first_name}!`,
            {
              reply_markup: {
                inline_keyboard: [
                  [
                    {
                      text: "üõ∞ –ü–æ—Å—Ç—Ä–æ–∏—Ç—å –∏–∑–±—É—à–∫—É",
                      callback_data: "name_izbushka",
                    },
                    {
                      text: "üè° –£–∑—Ä–µ—Ç—å –∏–∑–±—É—à–∫–∏",
                      callback_data: "show_izbushka",
                    },
                  ],
                ],
              },
            },
          );
          return;
        } else {
          ctx.reply(
            `üîí –û—Ö, —É–≤—ã –∏ –∞—Ö! –°–ª–æ–≤–µ—á–∫–æ, —á—Ç–æ –¥–æ –º–µ–Ω—è –¥–æ—à–ª–æ, —á–∞—Ä–∞–º —Ç–∞–π–Ω—ã–º –Ω–µ –æ—Ç–≤–µ—á–∞–µ—Ç. –ü—Ä–æ—à—É, –¥–∞–π –∑–Ω–∞—Ç—å –∏–Ω–æ–µ, —á—Ç–æ –∫–ª—é—á–æ–º —è–≤–ª—è–µ—Ç—Å—è –≤–µ—Ä–Ω—ã–º, —á—Ç–æ–± –ø—É—Ç—å —Ç–≤–æ–π –≤ —Ü–∞—Ä—Å—Ç–≤–æ –¥–∏–≤–Ω–æ–µ –æ—Ç–∫—Ä—ã—Ç—å —Å—É–º–µ–ª–∏ –±–µ–∑ –∑–∞–º–µ–¥–ª–µ–Ω–∏—è.`,
            {
              reply_markup: {
                force_reply: true,
              },
            },
          );
          return;
        }
      } catch (error) {
        ctx.reply(`–ß—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑.`);
        console.error(error, "message:text");
        return;
      }
    }
    //   TODO For water level
    if (originalMessageText?.includes("–ö–∞–∫ –Ω–∞–∑–æ–≤–µ–º –∏–∑–±—É—à–∫—É?")) {
      try {
        // const { error: createRoomError } = await supabase.from("rooms").insert({
        //   name: replyText,
        //   user_id,
        //   username,
        //   original_name: replyText,
        // });
        // console.log(createRoomError, "createRoomError");

        // TODO For water level
        // ctx.reply(
        //   "üóùÔ∏è –î–ª—è —Ç–æ–≥–æ —á—Ç–æ–±—ã —Å–≤—è–∑–∞—Ç—å –≤–∞—à–µ–≥–æ —Ü–∏—Ñ—Ä–æ–≤–æ–≥–æ –¥–≤–æ–π–Ω–∏–∫–∞ —Å –ª–∏—á–Ω—ã–º –Ω–µ–π—Ä–æ—Å–µ—Ç–µ–≤—ã–º –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–æ–º, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω, –≤—ã–¥–∞–Ω–Ω—ã–π BotFather.",
        //   {
        //     reply_markup: {
        //       force_reply: true,
        //     },
        //   },
        // );
        return;
      } catch (error) {
        console.error(error);
        return;
      }
    }

    if (
      originalMessageText?.includes(
        "üóùÔ∏è –î–ª—è —Ç–æ–≥–æ —á—Ç–æ–±—ã —Å–≤—è–∑–∞—Ç—å –≤–∞—à–µ–≥–æ —Ü–∏—Ñ—Ä–æ–≤–æ–≥–æ –¥–≤–æ–π–Ω–∏–∫–∞ —Å –ª–∏—á–Ω—ã–º –Ω–µ–π—Ä–æ—Å–µ—Ç–µ–≤—ã–º –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–æ–º, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω, –≤—ã–¥–∞–Ω–Ω—ã–π BotFather.",
      )
    ) {
      const userToken = ctx.update.message.text;

      const { data: dataRooms, error: errorRooms } = await supabase
        .from("rooms")
        .select("*")
        .eq("user_id", user_id)
        .order("id", { ascending: false });

      const lastElement = dataRooms && dataRooms[0];

      const translateName = transliterate(lastElement?.name);

      const newData = {
        id: lastElement?.id,
        name: translateName,
        original_name: lastElement?.name,
        type: "meets",
        username: ctx.message.from.username,
        user_id,
        token: userToken,
        chat_id: ctx.message.chat.id,
        lang: ctx.message.from.language_code,
      };
      console.log(newData, "newData");

      try {
        await create100MsRoom(newData);
        ctx.reply(
          `‚ú® –ü–æ—Å—Ç—Ä–æ–µ–Ω–∞ –∏–∑–±—É—à–∫–∞, –¥–∞–±—ã –æ—Ç–Ω—ã–Ω–µ –º–æ–≥–ª–∏ –≤—ã —Å–ª–æ–≤–µ—Å–Ω—ã–π –æ–±–º–µ–Ω —Ç–≤–æ—Ä–∏—Ç—å –∏ –∑–µ–º–ª—è–∫–æ–≤ —Å–≤–æ–∏—Ö –±–ª–∏–∂–∞–π—à–∏—Ö –ø—Ä–∏–∑—ã–≤–∞—Ç—å, –æ—Ç–ø—Ä–∞–≤—å –∏–º —Å–ª–æ–≤–µ—á–∫–æ –ø—Ä–æ—Ö–æ–¥–Ω–æ–µ.`,
        );
        ctx.reply(
          `üåå –ö–ª—é—á –∫–æ –≤—Ä–∞—Ç–∞–º –¢—Ä–∏–¥–µ–≤—è—Ç–æ–≥–æ –¶–∞—Ä—Å—Ç–≤–∞, –≥–¥–µ –º–µ—á—Ç—ã —Ç–≤–æ–∏ –æ–±—Ä–µ—Ç—É—Ç –æ–±—Ä–∞–∑, –∏ –º–∞–≥–∏—è –ø–ª–µ—Ç—ë—Ç—Å—è –ø–æ –≤–æ–ª–µ —Ç–≤–æ–µ–π. –°–∏–µ —Å–ª–æ–≤–µ—á–∫–æ –ø—Ä–æ—Ö–æ–¥–Ω–æ–µ –æ—Ç–≤–æ—Ä–∏—Ç –¥–≤–µ—Ä–∏ –∏–∑–±—É—à–∫–∏ –Ω–∞ –∫—É—Ä—å–∏—Ö –Ω–æ–∂–∫–∞—Ö, –≤–µ–¥—É—â–µ–π —Ç–µ–±—è –∫ —Ç–∞–π–Ω–∞–º –±–µ–∑–≥—Ä–∞–Ω–∏—á–Ω—ã–º –∏ —á—É–¥–µ—Å–∞–º –Ω–µ–∑—Ä–∏–º—ã–º.\n\nüóùÔ∏è –°–ª–æ–≤–µ—á–∫–æ: ${ctx.message.from.username}\nüè∞ –í—Ö–æ–¥ –≤ –¢—Ä–∏–¥–µ–≤—è—Ç–æ–µ –¶–∞—Ä—Å—Ç–≤–æ: @dao999nft_dev_bot`,
        );
        ctx.reply(
          `üè° –ù–∞–∂–º–∏ –Ω–∞ –∫–Ω–æ–ø–∫—É –∏ –∑–∞–ø—É—Å—Ç–∏ —á—É–¥–æ–¥–µ–π—Å—Ç–≤–µ–Ω–Ω—ã–µ –º–µ—Ö–∞–Ω–∏–∑–º—ã —Å–µ—Ç–∏ –º–∏—Ä–æ–≤–æ–π, —Ç—ã —Å–º–æ–∂–µ—à—å –º–≥–Ω–æ–≤–µ–Ω–Ω–æ –æ–∫–∏–Ω—É—Ç—å –≤–∑–æ—Ä–æ–º —Å–≤–æ–∏ –≤–ª–∞–¥–µ–Ω–∏—è, –Ω–µ –æ—Ç—Ö–æ–¥—è –æ—Ç –¥–æ–º–∞—à–Ω–µ–≥–æ –æ—á–∞–≥–∞.
        `,
          {
            reply_markup: {
              inline_keyboard: [
                [
                  {
                    text: "üè° –£–∑—Ä–µ—Ç—å –∏–∑–±—É—à–∫–∏",
                    callback_data: "show_izbushka",
                  },
                ],
              ],
            },
          },
        );
        return;
      } catch (error) {
        ctx.reply(`–ß—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑.`);
        return;
      }
    }
  } else {
    const query = ctx?.message?.text;

    try {
      if (query && aiKosheyUrl && aiKosheyFlowiseToken) {
        const feedback = await getAiFeedback({
          query,
          endpoint: aiKosheyUrl,
          token: aiKosheyFlowiseToken,
        });
        await ctx.reply(feedback, { parse_mode: "Markdown" });
        return;
      }
    } catch (error) {
      console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –æ—Ç–≤–µ—Ç–∞ AI:", error);
      return;
    }
    return;
  }
});

botAiKoshey.on("callback_query:data", async (ctx) => {
  console.log(ctx.callbackQuery, "callback_query");
  await ctx.replyWithChatAction("typing");

  const callbackData = ctx.callbackQuery.data;

  const username = ctx.update && ctx.update.callback_query.from.username;

  if (callbackData === "name_izbushka") {
    try {
      ctx.reply("–ö–∞–∫ –Ω–∞–∑–æ–≤–µ–º –∏–∑–±—É—à–∫—É?", {
        reply_markup: {
          force_reply: true,
        },
      });
      return;
    } catch (error) {
      console.error(error);
    }
  }

  if (callbackData === "show_izbushka") {
    const rooms = username && (await getRooms(username));
    // console.log(rooms, "rooms");
    try {
      ctx.reply("üè° –í—ã–±–µ—Ä–∏—Ç–µ –∏–∑–±—É—à–∫—É", {
        reply_markup: {
          inline_keyboard: rooms
            ? rooms
              .filter((room: any) => room)
              .map((room: any) => ({
                text: room.name,
                callback_data: `select_izbushka_${room.id}`,
              }))
              .reduce((acc: any, curr: any, index: number) => {
                const row = Math.floor(index / 1); // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–Ω–æ–ø–æ–∫ –≤ –æ–¥–Ω–æ–º —Ä—è–¥—É (–∑–¥–µ—Å—å 2 –∫–Ω–æ–ø–∫–∏ –≤ —Ä—è–¥—É)
                acc[row] = acc[row] || [];
                acc[row].push(curr);
                return acc;
              }, [])
            : [],
        },
      });
      return;
    } catch (error) {
      console.error("error show_izbushka", error);
      return;
    }
  }
  if (callbackData.includes("select_izbushka")) {
    const select_izbushka = callbackData.split("_")[2];

    if (select_izbushka) {
      username && await setSelectedIzbushka(username, select_izbushka);
    } else {
      ctx.reply(`ü§î –ß—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑.`);
    }

    ctx.reply(
      `üì∫ –ß—Ç–æ –∂, –ø—É—Ç–Ω–∏–∫ –¥–æ—Ä–æ–≥–æ–π, –¥–∞–±—ã —Ç—Ä–∞–Ω—Å–ª—è—Ü–∏—é –Ω–∞—á–∞—Ç—å, –Ω–∞–∂–º–∏ –∫–Ω–æ–ø–∫—É "Izbushka" —Å–º–µ–ª–µ–µ –∏ –≤–µ—Å–µ–ª–∏—Å—å, –∏–±–æ –≤—Å–µ –ø—Ä–∏–≥–æ—Ç–æ–≤–ª–µ–Ω–æ –∫ –Ω–∞—á–∞–ª—É —Ç–≤–æ–µ–≥–æ –ø—É—Ç–µ—à–µ—Å—Ç–≤–∏—è –ø–æ —Ü–∏—Ñ—Ä–æ–≤—ã–º –ø—Ä–æ—Å—Ç–æ—Ä–∞–º!\nüåü –¢–∞–∫–∂–µ –ø–æ–¥–µ–ª–∏—Å—å —ç—Ç–æ–π —Å—Å—ã–ª–∫–æ—é —Å –¥—Ä—É–≥–æ–º —Å–≤–æ–∏–º, —á—Ç–æ–±—ã –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—Å—è –æ–Ω –∫ –∏–∑–±—É—à–∫–µ —Ç–≤–æ–µ–π –∏ –Ω–µ –∑–∞–±—É–¥—å —Å–∫–∞–∑–∞—Ç—å –µ–º—É —Ç—ã —Å–ª–æ–≤–µ—á–∫–æ –ø—Ä–æ—Ö–æ–¥–Ω–æ–µ –≤ –¶–∞—Ä—Å—Ç–≤–æ –¢—Ä–∏–¥–µ–≤—è—Ç–æ–µ, –∫–æ–∏–º —è–≤–ª—è–µ—Ç—Å—è —Ç–≤–æ–π —Ç–µ–ª–µ–≥—Ä–∞–º —é–∑–µ—Ä–Ω–µ–π–º.
      `,
    );

    ctx.reply(
      `–ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –≤ –∏–∑–±—É—à–∫—É. –ù–∞–∂–º–∏ –Ω–∞ –∫–Ω–æ–ø–∫—É —á—Ç–æ–±—ã –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è!\n\nhttps://t.me/ai_koshey_bot?start=${select_izbushka}`,
    );
    return;
  }
});

await botAiKoshey.api.setMyCommands([
  {
    command: "/start",
    description: "Start the bot",
  },
  // {
  //   command: "/room",
  //   description: "Create a room",
  // },
]);

const handleUpdate = webhookCallback(botAiKoshey, "std/http");

Deno.serve(async (req) => {
  try {
    const url = new URL(req.url);
    if (url.searchParams.get("secret") !== Deno.env.get("FUNCTION_SECRET")) {
      return new Response("not allowed", { status: 405 });
    }

    return await handleUpdate(req);
  } catch (err) {
    console.error(err);
  }
});
